# -*- coding: utf-8 -*-
"""agentes_aleatorios.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mFsPyfePsltO6qqucvzm1ZrnZPCF0qhj
"""

!pip install numpy matplotlib mesa==3.0 -q
!pip install --pre mesa[viz] -q

# ==== DEPENDENCIAS ====
# Asegúrate de haber ejecutado en una celda previa:


from mesa import Agent, Model
from mesa.space import MultiGrid
from mesa.time import RandomActivation
from mesa.datacollection import DataCollector

import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from IPython.display import HTML
import numpy as np
from collections import defaultdict
import json
from pathlib import Path

# ------------------------------------------------------------
#                  LOGGER COMPATIBLE CON UNITY
# ------------------------------------------------------------


class SimLogger:
    """
    Emite:
      - steps: lista de eventos puntuales (spawn/move/...).
      - snapshots: estado FINAL por tick (i.e., coincide con la animación frame i=t).
    Protocolo de ticks:
      - t=0  => estado inicial (snapshot) + spawns iniciales (si quieres registrar).
      - t>=1 => resultado de cada llamada a model.step().
    """

    def __init__(self):
        self.steps = []
        self.snapshots = []   # lista de dicts {"t": t, "agents":[...], ...}

    # ---------- Eventos (flujo) ----------
    def spawn_agent(self, aid, r, c, t):
        self.steps.append({"t": t, "type": "spawn_agent",
                           "id": str(aid), "r": r, "c": c})

    def move(self, aid, from_pos, to_pos, t):
        self.steps.append({
            "t": t, "type": "move", "id": str(aid),
            "from": {"r": from_pos[1] + 1, "c": from_pos[0] + 1},
            "to":   {"r": to_pos[1] + 1,   "c": to_pos[0] + 1}
        })

    def reveal_poi(self, r, c, kind, t):
        self.steps.append({"t": t, "type": "reveal_poi",
                           "r": r, "c": c, "kind": kind})

    def rescue(self, r, c, t):
        self.steps.append({"t": t, "type": "rescue", "r": r, "c": c})

    def riot_spread(self, from_pos, to_pos, t):
        self.steps.append({
            "t": t, "type": "riot_spread",
            "from": {"r": from_pos[1] + 1, "c": from_pos[0] + 1},
            "to":   {"r": to_pos[1] + 1,   "c": to_pos[0] + 1}
        })

    def riot_contained(self, r, c, t):
        self.steps.append({"t": t, "type": "riot_contained", "r": r, "c": c})

    def damage_inc(self, amount, t):
        self.steps.append(
            {"t": t, "type": "damage_inc", "amount": int(amount)})

    # ---------- Snapshots (estado final por tick) ----------
    def snapshot_tick(self, model, t, include_pois=False, include_riots=False, include_doors=False):
        snap = {"t": int(t)}

        # Agents
        agents = []
        for a in model.schedule.agents:
            if getattr(a, "pos", None) is not None:
                agents.append(
                    {"id": str(a.unique_id), "r": a.pos[1] + 1, "c": a.pos[0] + 1})
        agents.sort(key=lambda x: int(x["id"]))
        snap["agents"] = agents

        if include_pois:
            pois = []
            for (x, y), contents in model.cell_contents.items():
                # “POI visibles” o “todos”, según prefieras. Aquí: todos.
                if any(isinstance(c, Hostage) for c in contents):
                    pois.append({"r": y + 1, "c": x + 1, "kind": "v"})
                elif any(isinstance(c, FalseAlarm) for c in contents):
                    pois.append({"r": y + 1, "c": x + 1, "kind": "f"})
            snap["pois"] = sorted(pois, key=lambda p: (p["r"], p["c"]))

        if include_riots:
            riots = []
            for (x, y), contents in model.cell_contents.items():
                d = next((c for c in contents if isinstance(c, Disturbance)), None)
                if d:
                    riots.append(
                        {"r": y + 1, "c": x + 1, "severity": d.severity})
            snap["riots"] = sorted(riots, key=lambda p: (p["r"], p["c"]))

        if include_doors:
            # Si representas puertas como objetos dentro de una celda, aquí podrías
            # volcar su estado. (O si pasas una estructura explícita en config).
            doors = []
            for (x, y), contents in model.cell_contents.items():
                for g in contents:
                    if isinstance(g, Gate):
                        doors.append(
                            {"r": y + 1, "c": x + 1, "open": bool(g.is_open)})
            snap["doors"] = sorted(doors, key=lambda d: (d["r"], d["c"]))

        self.snapshots.append(snap)

    # ---------- Empaquetado ----------
    def to_simlog(self, result, rescued, lost, damage, meta=None):
        out = {
            "result": result,
            "rescued": rescued,
            "lost": lost,
            "damage": damage,
            "steps": self.steps,
            "snapshots": self.snapshots
        }
        if meta:
            out["meta"] = meta  # filas/cols, semántica de ticks, etc.
        return out

# ------------------------------------------------------------
#                        ENTIDADES
# ------------------------------------------------------------
class Hostage:
    """Rehén (objeto pasivo)."""

    def __init__(self, unique_id):
        self.unique_id = unique_id


class FalseAlarm:
    """Falsa alarma (objeto pasivo)."""

    def __init__(self, unique_id):
        self.unique_id = unique_id


class Gate:
    """Reja/puerta en una celda (simplificación)."""

    def __init__(self, unique_id, is_open=False):
        self.unique_id = unique_id
        self.is_open = is_open


class Disturbance:
    """Disturbio (riot) con severidad."""

    def __init__(self, unique_id, severity='mild'):
        self.unique_id = unique_id
        self.severity = severity  # 'mild', 'active', 'grave'
        self.turns_in_current_state = 0

# ------------------------------------------------------------
#                     RENDER DE LA CUADRÍCULA
# ------------------------------------------------------------
def get_grid(model):
    """
    Matriz para animación:
    - Shape = (height*2+1, width*2+1)  -> [filas(Y), columnas(X)]
    - Celdas "centro" en (y*2+1, x*2+1)
    - Muros (top/left/bottom/right) en segmentos vecinos.
    """
    H = model.grid.height
    W = model.grid.width
    canvas = np.zeros((H * 2 + 1, W * 2 + 1), dtype=np.int32)

    # Muros por celda
    for (x, y), walls in model.walls.items():
        cy, cx = y * 2 + 1, x * 2 + 1  # (fila, col) en canvas

        if walls.get('top', False):
            canvas[cy - 1, cx] = 1
        if walls.get('bottom', False):
            canvas[cy + 1, cx] = 1
        if walls.get('left', False):
            canvas[cy, cx - 1] = 1
        if walls.get('right', False):
            canvas[cy, cx + 1] = 1

    # Borde exterior (opcional)
    canvas[0, :] = 1
    canvas[-1, :] = 1
    canvas[:, 0] = 1
    canvas[:, -1] = 1

    # Objetos/POIs/puertas (centro de celda)
    for (x, y), contents in model.cell_contents.items():
        cy, cx = y * 2 + 1, x * 2 + 1

        # Prioridad por tipo (si quieres otra, ajusta)
        if any(isinstance(c, Hostage) for c in contents):
            canvas[cy, cx] = 3
            continue

        if any(isinstance(c, Disturbance) for c in contents):
            d = next(c for c in contents if isinstance(c, Disturbance))
            canvas[cy, cx] = 8 if d.severity == 'grave' else (
                5 if d.severity == 'active' else 4)
            continue

        if any(isinstance(c, FalseAlarm) for c in contents):
            canvas[cy, cx] = 7
            continue

        if any(isinstance(c, Gate) for c in contents):
            g = next(c for c in contents if isinstance(c, Gate))
            canvas[cy, cx] = 9 if g.is_open else 10
            continue

    # Entradas (si el centro está vacío)
    for (ex, ey) in getattr(model, "entry_points", []):
        cy, cx = ey * 2 + 1, ex * 2 + 1
        if canvas[cy, cx] == 0:
            canvas[cy, cx] = 6

    # Agentes al final (para que se vean encima)
    for agent in model.schedule.agents:
        if getattr(agent, "pos", None) is None:
            continue
        x, y = agent.pos
        cy, cx = y * 2 + 1, x * 2 + 1
        canvas[cy, cx] = 2

    return canvas


def get_grid_board(model):
    """
    Devuelve una matriz HxW (6x8) con el contenido por celda:
      0 = vacío
      2 = agente
      3 = rehén
      4 = disturbio leve
      5 = disturbio activo
      8 = disturbio grave
      7 = falsa alarma
      6 = punto de entrada
      9 = reja abierta
     10 = reja cerrada
    Nota: NO dibuja muros (pero la lógica sí los respeta al mover).
    """
    H, W = model.grid.height, model.grid.width
    M = np.zeros((H, W), dtype=np.int32)

    # puntos de entrada (si no hay algo encima)
    for (ex, ey) in getattr(model, "entry_points", []):
        if M[ey, ex] == 0:
            M[ey, ex] = 6

    # objetos (rehén, disturbio, falsa, puerta)
    for (x, y), contents in model.cell_contents.items():
        # prioridad:
        if any(isinstance(c, Hostage) for c in contents):
            M[y, x] = 3
            continue

        if any(isinstance(c, Disturbance) for c in contents):
            d = next(c for c in contents if isinstance(c, Disturbance))
            M[y, x] = 8 if d.severity == "grave" else (
                5 if d.severity == "active" else 4)
            continue

        if any(isinstance(c, FalseAlarm) for c in contents):
            M[y, x] = 7
            continue

        if any(isinstance(c, Gate) for c in contents):
            g = next(c for c in contents if isinstance(c, Gate))
            M[y, x] = 9 if g.is_open else 10
            continue

    # agentes encima de todo
    for a in model.schedule.agents:
        if getattr(a, "pos", None) is None:
            continue
        x, y = a.pos
        M[y, x] = 2

    return M

# ------------------------------------------------------------
#                     AGENTE TÁCTICO (POLICÍA)
# ------------------------------------------------------------
class TacticalAgent(Agent):
    def __init__(self, unique_id, model):
        super().__init__(model)
        self.unique_id = unique_id
        self.action_points = 4
        self.carrying_hostage = False

    def step(self):
        self.action_points = 4

        while self.action_points > 0:
            possible = []
            here = self.model.get_contents_at(self.pos)

            # 1) Movimiento ortogonal (considera muros/puertas cerradas)
            for nb in self.model.grid.get_neighborhood(self.pos, moore=False, include_center=False):
                if self.model.can_move_to(self.pos, nb):
                    cost = 1
                    nb_cont = self.model.get_contents_at(nb)
                    if any(isinstance(c, Disturbance) for c in nb_cont):
                        cost = 2
                    if self.action_points >= cost:
                        possible.append(("move", nb, cost))

            # 2) Rescatar rehén (2 AP)
            if not self.carrying_hostage:
                h = next((c for c in here if isinstance(c, Hostage)), None)
                if h and self.action_points >= 2:
                    possible.append(("rescue", h, 2))

            # 3) Investigar falsa alarma (1 AP)
            fa = next((c for c in here if isinstance(c, FalseAlarm)), None)
            if fa and self.action_points >= 1:
                possible.append(("investigate", fa, 1))

            # 4) Dejar rehén en entrada (1 AP)
            if self.carrying_hostage and self.pos in self.model.entry_points and self.action_points >= 1:
                possible.append(("dropoff", None, 1))

            # 5) Contener disturbio (1 o 2 AP según severidad)
            d = next((c for c in here if isinstance(c, Disturbance)), None)
            if d:
                if d.severity == "mild" and self.action_points >= 1:
                    possible.append(("contain", d, 1))
                elif d.severity == "active" and self.action_points >= 2:
                    possible.append(("contain", d, 2))

            if not possible:
                break

            action, target, cost = self.random.choice(possible)

            if action == "move":
                from_pos = self.pos
                self.model.grid.move_agent(self, target)
                if hasattr(self.model, "logger"):
                    self.model.logger.move(
                        self.unique_id, from_pos, target, t=self.model.turn_counter + 1
                    )

                # --- Revelar si hay POI al ENTRAR en la celda ---
                revealed_now = self.model.reveal_if_needed(self.pos)

                # Si se reveló un POI, corta turno para separar ticks
                if revealed_now:
                    self.action_points = 0
                    continue

            elif action == "rescue":
                # Asegura revelación antes de retirar ícono
                self.model.reveal_if_needed(self.pos)

                # Log de "rescue" EN LA CELDA DEL POI
                if hasattr(self.model, "logger"):
                    self.model.logger.rescue(
                        self.pos[1] + 1, self.pos[0] + 1, t=self.model.turn_counter + 1
                    )

                # Levantar rehén
                self.carrying_hostage = True
                self.model.remove_entity(target, self.pos)

            elif action == "investigate":
                self.model.reveal_if_needed(self.pos)
                self.model.false_alarms_investigated += 1
                self.model.remove_entity(target, self.pos)

            elif action == "dropoff":
                self.carrying_hostage = False
                self.model.hostages_rescued += 1
                # No se emite 'rescue' aquí; el icono ya se quitó al pickup.

            elif action == "contain":
                self.model.remove_entity(target, self.pos)
                if hasattr(self.model, "logger"):
                    self.model.logger.riot_contained(
                        self.pos[1] + 1, self.pos[0] + 1, t=self.model.turn_counter + 1
                    )

            self.action_points -= cost

# ------------------------------------------------------------
#                        MODELO PRINCIPAL
#      (LEE config.json Y GENERA LOG PARA UNITY)
# ------------------------------------------------------------
class RescueModel(Model):
    def __init__(self, config_path="config.json"):
        super().__init__()
        cfg = self._load_config(config_path)

        rows = cfg["rows"]  # filas = alto
        cols = cfg["cols"]  # columnas = ancho

        # width = cols, height = rows (Mesa)
        self.grid = MultiGrid(cols, rows, torus=False)
        self.schedule = RandomActivation(self)
        self.cell_contents = defaultdict(list)
        self.running = True

        # Métricas
        self.hostages_rescued = 0
        self.hostages_lost = 0
        self.structural_damage = 0
        self.false_alarms_investigated = 0
        self.next_entity_id = 0
        self.turn_counter = 0
        self.min_hidden_markers = 3

        # --- Construcción desde config ---
        # {(x,y): {'top','left','bottom','right'}}
        self.walls = {}
        self.entry_points = []        # [(x,y), ...]
        self._build_from_config(cfg)

        # Logger
        self.logger = SimLogger()

        # POIs ya revelados (para no revelar 2 veces)
        self.revealed_pois = set()  # set de posiciones (x,y)

        # Agentes iniciales (6) en entradas (puede repetir)
        for _ in range(6):
            a = TacticalAgent(self.get_next_id(), self)
            self.schedule.add(a)
            ep = self.random.choice(self.entry_points)
            self.grid.place_agent(a, ep)

        # Log de spawns
        for a in self.schedule.agents:
            if getattr(a, "pos", None) is not None:
                r, c = a.pos[1] + 1, a.pos[0] + 1  # a Unity: base 1
                self.logger.spawn_agent(a.unique_id, r, c, t=0)

        # Stats iniciales
        self.initial_hostages = sum(1 for cont in self.cell_contents.values()
                                    for it in cont if isinstance(it, Hostage))
        self.initial_alarms = sum(1 for cont in self.cell_contents.values()
                                  for it in cont if isinstance(it, FalseAlarm))
        self.initial_disturbances = sum(1 for cont in self.cell_contents.values()
                                        for it in cont if isinstance(it, Disturbance))

        # self.datacollector = DataCollector(model_reporters={"Grid": get_grid})
        self.datacollector = DataCollector(
            model_reporters={"Grid": lambda m: np.array(get_grid_board(m))}
        )

        # Snapshot inicial (t=0) — coincide con frame 0 de la animación
        self.logger.snapshot_tick(
            self, t=0, include_pois=False, include_riots=False, include_doors=False)

    # ---------- construcción desde config ----------

    def _load_config(self, path):
        path = Path(path)
        with path.open("r", encoding="utf-8") as f:
            return json.load(f)

    def _parse_cells(self, cfg):
        if "cells" in cfg and cfg["cells"]:
            return cfg["cells"]
        # respaldo: cellRows "abcd abcd ..."
        rows = cfg["rows"]
        cols = cfg["cols"]
        out = []
        for line in cfg["cellRows"]:
            parts = line.strip().split()
            if len(parts) != cols:
                raise ValueError(
                    f"Línea con {len(parts)} columnas; se esperaban {cols}.")
            out.append(parts)
        if len(out) != rows:
            raise ValueError(
                f"Se recibieron {len(out)} filas; se esperaban {rows}.")
        return out

    def _build_from_config(self, cfg):
        # Paredes
        cells = self._parse_cells(cfg)
        rows, cols = cfg["rows"], cfg["cols"]
        for r in range(rows):
            for c in range(cols):
                code = cells[r][c]  # "abcd" = up,left,down,right
                if len(code) != 4:
                    raise ValueError(
                        f"Celda ({r},{c}) código inválido: {code}")
                x, y = c, r
                self.walls[(x, y)] = {
                    "top":    code[0] == "1",
                    "left":   code[1] == "1",
                    "bottom": code[2] == "1",
                    "right":  code[3] == "1",
                }

        # Entradas (r,c) base 1 -> (x,y) base 0
        self.entry_points = []
        for e in cfg.get("entries", []):
            r, c = e["r"], e["c"]
            self.entry_points.append((c - 1, r - 1))

        # POIs
        for p in cfg.get("pois", []):
            r, c, kind = p["r"], p["c"], p["kind"]
            pos = (c - 1, r - 1)
            if kind == "v":
                self.cell_contents[pos].append(Hostage(self.get_next_id()))
            else:
                self.cell_contents[pos].append(FalseAlarm(self.get_next_id()))

        # Disturbios (riots)
        for rr in cfg.get("riots", []):
            r, c = rr["r"], rr["c"]
            pos = (c - 1, r - 1)
            self.cell_contents[pos].append(
                Disturbance(self.get_next_id(), "mild"))

        # Puertas: simplificación como objeto en una celda
        for d in cfg.get("doors", []):
            r1, c1, r2, c2 = d["r1"], d["c1"], d["r2"], d["c2"]
            is_open = bool(d.get("open", False))
            pos1 = (c1 - 1, r1 - 1)
            self.cell_contents[pos1].append(Gate(self.get_next_id(), is_open))

    # ---------- utilidades juego ----------
    def get_next_id(self):
        self.next_entity_id += 1
        return self.next_entity_id

    def get_contents_at(self, pos):
        return self.grid.get_cell_list_contents([pos]) + self.cell_contents.get(pos, [])

    def remove_entity(self, entity, pos):
        if pos in self.cell_contents and entity in self.cell_contents[pos]:
            self.cell_contents[pos].remove(entity)

    def can_move_to(self, from_pos, to_pos):
        x2, y2 = to_pos
        if not (0 <= x2 < self.grid.width and 0 <= y2 < self.grid.height):
            return False

        x1, y1 = from_pos
        dx, dy = x2 - x1, y2 - y1

        # Pared en origen
        w = self.walls.get(from_pos, {})
        if dx == 1 and w.get('right'):
            return False
        elif dx == -1 and w.get('left'):
            return False
        elif dy == 1 and w.get('bottom'):
            return False
        elif dy == -1 and w.get('top'):
            return False

        # Puerta cerrada en destino bloquea
        contents = self.get_contents_at(to_pos)
        if any(isinstance(g, Gate) and not g.is_open for g in contents):
            return False

        return True

    def has_wall_between(self, pos1, pos2):
        x1, y1 = pos1
        x2, y2 = pos2
        dx, dy = x2 - x1, y2 - y1
        w = self.walls.get(pos1, {})
        if dx == 1 and w.get('right'):
            return True
        elif dx == -1 and w.get('left'):
            return True
        elif dy == 1 and w.get('bottom'):
            return True
        elif dy == -1 and w.get('top'):
            return True
        return False

    def break_wall_between(self, pos1, pos2):
        x1, y1 = pos1
        x2, y2 = pos2
        dx, dy = x2 - x1, y2 - y1

        w1 = self.walls.get(pos1, {})
        w2 = self.walls.get(pos2, {})

        if dx == 1 and w1.get('right'):
            w1['right'] = False
            w2['left'] = False
        elif dx == -1 and w1.get('left'):
            w1['left'] = False
            w2['right'] = False
        elif dy == 1 and w1.get('bottom'):
            w1['bottom'] = False
            w2['top'] = False
        elif dy == -1 and w1.get('top'):
            w1['top'] = False
            w2['bottom'] = False

        self.walls[pos1] = w1
        self.walls[pos2] = w2

    def get_available_cell(self):
        # libre de agente y de Gate cerrada
        for _ in range(200):
            pos = (self.random.randrange(self.grid.width),
                   self.random.randrange(self.grid.height))
            cont = self.get_contents_at(pos)
            has_agent = any(isinstance(c, TacticalAgent) for c in cont)
            has_closed_gate = any(isinstance(
                c, Gate) and not c.is_open for c in cont)
            if not (has_agent or has_closed_gate):
                return pos
        # fallback
        return (self.random.randrange(self.grid.width), self.random.randrange(self.grid.height))

    def place_passive_entity(self, entity_class):
        entity = entity_class(self.get_next_id(),
                              'mild') if entity_class == Disturbance else entity_class(self.get_next_id())
        pos = self.get_available_cell()
        self.cell_contents[pos].append(entity)

    def count_hidden_markers(self):
        return sum(1 for cont in self.cell_contents.values()
                   for it in cont if isinstance(it, (Hostage, FalseAlarm)))

    def maintain_minimum_markers(self):
        while self.count_hidden_markers() < self.min_hidden_markers:
            cls = self.random.choices(
                [Hostage, FalseAlarm], weights=[0.7, 0.3], k=1)[0]
            self.place_passive_entity(cls)

    def advance_disturbances(self):
        # Progresión de disturbios
        for pos, cont in list(self.cell_contents.items()):
            ds = [d for d in cont if isinstance(d, Disturbance)]
            for d in ds:
                d.turns_in_current_state += 1
                if d.severity == "mild" and d.turns_in_current_state >= 4:
                    d.severity = "active"
                    d.turns_in_current_state = 0
                elif d.severity == "active" and d.turns_in_current_state >= 6:
                    d.severity = "grave"
                    self.handle_explosion(pos, cont)

        # 5% chance de nuevo disturbio
        if self.random.random() < 0.05:
            pos = self.get_available_cell()
            cont = self.get_contents_at(pos)
            if not any(isinstance(c, Disturbance) for c in cont):
                self.cell_contents[pos].append(
                    Disturbance(self.get_next_id(), "mild"))
                # Si quieres verlo en Unity como "spread" puedes loggear así (opcional):
                # if hasattr(self, "logger"):
                #     self.logger.riot_spread(pos, pos)

    def handle_explosion(self, pos, contents):
        self.structural_damage += 1
        if hasattr(self, "logger"):
            self.logger.damage_inc(1, t=self.turn_counter + 1)

        neighbors = [(pos[0] + dx, pos[1] + dy)
                     for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]]
        for nb in neighbors:
            if self.has_wall_between(pos, nb) and self.random.random() < 0.3:
                self.break_wall_between(pos, nb)

        # Romper puertas cercanas
        for nb in neighbors:
            if nb in self.cell_contents:
                gs = [g for g in self.cell_contents[nb] if isinstance(g, Gate)]
                for g in gs:
                    if self.random.random() < 0.5:
                        self.remove_entity(g, nb)

        # Rehenes perdidos en la celda
        for h in [h for h in contents if isinstance(h, Hostage)]:
            self.hostages_lost += 1
            self.remove_entity(h, pos)

        # Eliminar disturbio
        for d in [d for d in contents if isinstance(d, Disturbance)]:
            self.remove_entity(d, pos)

    def check_game_over(self):
        if self.hostages_rescued >= 7 or self.hostages_lost >= 4 or self.structural_damage >= 25:
            self.running = False

    def step(self):
        # t del tick que vamos a resolver (1,2,3,...)
        t = self.turn_counter + 1

        # Avanza agentes (ellos emiten eventos con t actual)
        self.schedule.step()

        # Sistema
        self.advance_disturbances()
        self.maintain_minimum_markers()
        self.check_game_over()

        # DataCollector (para animación, frame i=t)
        self.datacollector.collect(self)

        # Snapshot final del tick (estado que debería verse en frame t)
        self.logger.snapshot_tick(
            self, t=t, include_pois=False, include_riots=False, include_doors=False)

        # Cierra tick
        self.turn_counter = t

    # ---------- NUEVO: revelar POI una sola vez, cuando se entra a la celda ----------
    def reveal_if_needed(self, pos):
        """
        Si en 'pos' hay Hostage o FalseAlarm y aún no ha sido revelado,
        emite 'reveal_poi' (v/f) y marca como revelado.
        Devuelve True si se reveló ahora; False si ya estaba revelado o no hay POI.
        """
        if pos in self.revealed_pois:
            return False

        contents = self.get_contents_at(pos)
        kind = None
        if any(isinstance(c, Hostage) for c in contents):
            kind = "v"
        elif any(isinstance(c, FalseAlarm) for c in contents):
            kind = "f"

        if kind is None:
            return False

        self.revealed_pois.add(pos)
        if hasattr(self, "logger"):
            self.logger.reveal_poi(
                pos[1] + 1, pos[0] + 1, kind, t=self.turn_counter + 1)
        return True

# ================================
#   EJECUCIÓN + DIAGNÓSTICO + ANIM
# ================================
plt.rcParams["animation.html"] = "jshtml"
matplotlib.rcParams['animation.embed_limit'] = 2**128

# 0) Crea el modelo
print("Iniciando simulación desde config.json (6x8)...")
model = RescueModel("config.json")

# 1) Añade al DataCollector un snapshot con (id,r,c) por tick
#    (si ya definiste DataCollector arriba, lo reemplazamos aquí)
model.datacollector = DataCollector(
    model_reporters={
        "Grid": lambda m: np.array(get_grid_board(m)),
        "AgentsRC": lambda m: sorted(
            (str(a.unique_id), a.pos[1] + 1, a.pos[0] + 1)
            for a in m.schedule.agents
            if getattr(a, "pos", None) is not None
        )
    }
)

# 2) Colecta estado inicial (frame 0 / tick 0 snapshot)
model.datacollector.collect(model)

# 3) Corre la simulación
MAX_STEPS = 500
for i in range(MAX_STEPS):
    if not model.running:
        break
    model.step()
    if (i + 1) % 50 == 0:
        print(f"Paso {i + 1}: Rescatados={model.hostages_rescued}, Perdidos={model.hostages_lost}, Daño={model.structural_damage}")

print("=" * 60)
print(f"Simulación terminada en {model.turn_counter} pasos.")
print(f"Rehenes Rescatados: {model.hostages_rescued}")
print(f"Rehenes Perdidos: {model.hostages_lost}")
print(f"Daño Estructural: {model.structural_damage}")
print(f"Falsas Alarmas Investigadas: {model.false_alarms_investigated}")

result = "win" if model.hostages_rescued >= 7 else ("lose_lost" if model.hostages_lost >= 4 else (
    "lose_collapse" if model.structural_damage >= 25 else "timeout"))
print("RESULTADO:", result)

# 4) Volcar log.json
simlog = model.logger.to_simlog(
    result, model.hostages_rescued, model.hostages_lost, model.structural_damage)
with open("log.json", "w", encoding="utf-8") as f:
    json.dump(simlog, f, ensure_ascii=False, indent=2)
print("log.json generado en el directorio actual.")

# 5) DIAGNÓSTICO: imprime los primeros 10 ticks
results = model.datacollector.get_model_vars_dataframe()
frames = [np.array(g) for g in results["Grid"]]  # copias seguras
# lista de listas [(id,r,c), ...]
agents_per_tick = list(results["AgentsRC"])

# index de último tick simulado (frame index == tick)
last_tick = len(agents_per_tick) - 1

# agrupa steps por t para contar eventos por tick
from collections import defaultdict, Counter
steps_by_t = defaultdict(list)
for s in simlog["steps"]:
    steps_by_t[s["t"]].append(s["type"])

print("\n--- PRIMEROS 10 TICKS (snapshot final del tick + resumen de eventos) ---")
for t in range(min(10, last_tick + 1)):
    types = Counter(steps_by_t.get(t, []))
    snap = agents_per_tick[t]  # [(id,r,c), ...] al FINAL de ese tick
    snap_str = ", ".join([f"{aid}@({r},{c})" for (aid, r, c) in snap])
    types_str = ", ".join(
        [f"{k}:{v}" for k, v in sorted(types.items())]) or "—"
    print(f"t={t:>2} | eventos[{types_str}] | agentes[{snap_str}]")

# 6) Animación (frame i == snapshot del tick i)
fig, ax = plt.subplots(figsize=(8, 6))
ax.set_xticks(range(model.grid.width))
ax.set_yticks(range(model.grid.height))
ax.set_xticklabels([])
ax.set_yticklabels([])
ax.set_title("Simulación (6x8, sin muros dibujados)", fontsize=14)

colors = ['#FFFFFF', '#000000', '#2196F3', '#4CAF50', '#FFC107',
          '#F44336', '#9C27B0', '#FF9800', '#8B0000', '#00FF00', '#808080']
cmap = matplotlib.colors.ListedColormap(colors)
norm = matplotlib.colors.BoundaryNorm(list(range(12)), cmap.N)

# IMPORTANTE: origin='upper' para que (r,c) coincida visualmente con tus coordenadas 1-based
patch = ax.imshow(frames[0], cmap=cmap, norm=norm, origin='upper')


def animate(i):
    patch.set_data(frames[i])
    ax.set_title(f"Simulación - Tick {i}", fontsize=14)  # i == t
    return [patch]


anim = animation.FuncAnimation(fig, animate, frames=len(
    frames), interval=200, blit=False, repeat=False)
plt.tight_layout()

display(HTML(anim.to_jshtml()))

# Parámetros
BATCH_SIZE = 100
MAX_STEPS = 500

wins = 0
losses = 0
timeouts = 0
steps_total = 0

for run in range(BATCH_SIZE):
    model = RescueModel("config.json")
    model.datacollector = DataCollector(
        model_reporters={
            "Grid": lambda m: np.array(get_grid_board(m)),
            "AgentsRC": lambda m: sorted(
                (str(a.unique_id), a.pos[1] + 1, a.pos[0] + 1)
                for a in m.schedule.agents
                if getattr(a, "pos", None) is not None
            )
        }
    )
    model.datacollector.collect(model)

    for i in range(MAX_STEPS):
        if not model.running:
            break
        model.step()

    # Resultado de la corrida
    steps_total += model.turn_counter
    if model.hostages_rescued >= 7:
        wins += 1
    elif model.hostages_lost >= 4:
        losses += 1
    elif model.structural_damage >= 25:
        losses += 1
    else:
        timeouts += 1

# Resumen final
print("=" * 60)
print(f"Simulaciones totales: {BATCH_SIZE}")
print(f"Victorias: {wins}")
print(f"Derrotas: {losses}")
print(f"Timeouts: {timeouts}")
print(f"Promedio de pasos: {steps_total / BATCH_SIZE:.2f}")